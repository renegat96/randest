\documentclass[12pt,a4paper]{article}

%\usepackage[square]{natbib}
\usepackage[english,bulgarian]{babel}
\usepackage[svgnames]{xcolor}
\usepackage[unicode]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{etoolbox}
\usepackage{float}
\usepackage{framed}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{libertine} % or any other font package
\usepackage{tikz}
\usepackage[normalem]{ulem}
\usepackage{url}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\theoremstyle{plain}
\newtheorem{defn}{Дефиниция}

\newcommand*\quotefont{\fontfamily{LinuxLibertineT-LF}} % selects Libertine as the quote font
\newcommand*\quotesize{60} % if quote size changes, need a way to make shifts relative
% Make commands for the quotes
\newcommand*{\openquote}
   {\tikz[remember picture,overlay,xshift=-4ex,yshift=-2.5ex]
   \node (OQ) {\quotefont\fontsize{\quotesize}{\quotesize}\selectfont``};\kern0pt}

\newcommand*{\closequote}[1]
  {\tikz[remember picture,overlay,xshift=4ex,yshift={#1}]
   \node (CQ) {\quotefont\fontsize{\quotesize}{\quotesize}\selectfont''};}

% select a colour for the shading
\colorlet{shadecolor}{Azure}

\newcommand*\shadedauthorformat{\emph} % define format for the author argument

% Now a command to allow left, right and centre alignment of the author
\newcommand*\authoralign[1]{%
  \if#1l
    \def\authorfill{}\def\quotefill{\hfill}
  \else
    \if#1r
      \def\authorfill{\hfill}\def\quotefill{}
    \else
      \if#1c
        \gdef\authorfill{\hfill}\def\quotefill{\hfill}
      \else\typeout{Invalid option}
      \fi
    \fi
  \fi}
% wrap everything in its own environment which takes one argument (author) and one optional argument
% specifying the alignment [l, r or c]
%
\newenvironment{shadequote}[2][l]%
{\authoralign{#1}
\ifblank{#2}
   {\def\shadequoteauthor{}\def\yshift{-2ex}\def\quotefill{\hfill}}
   {\def\shadequoteauthor{\par\authorfill\shadedauthorformat{#2}}\def\yshift{2ex}}
\begin{snugshade}\begin{quote}\openquote}
{\shadequoteauthor\quotefill\closequote{\yshift}\end{quote}\end{snugshade}}
% shadequote taken from http://tex.stackexchange.com/questions/16964/block-quote-with-big-quotation-marks on Dec 1 2013 09:42:53

\title{Randest - a randomness tests collection}
\author{Христо Стоянов}
\date{1 декември 2013}

\begin{document}

\maketitle

\begin{shadequote}[r]{John von Neumann}
    Any one who considers arithmetical methods of producing random digits is, of course, in a state of sin.
\end{shadequote}

\begin{abstract}
    
    Използването на случайни числа намира широка употреба в множество статистически и алгоритмични задачи. След възникналата нужда се създават различни начини за генериране на редица от произволни числа - хвърляне на зар, теглене на топче от торба, раздаване на карти. В средата на XX век се създават първите устройства с такава цел. За оценяването на получените редици се описват множество статистически тестове, които се стремят да открият вътрешна зависимост. Randest е софтуерна библиотека от стохастични тестове, имплементирани на C++. Тестовете за това дали редица от числа е случайна са генерализирани и разчитат на единствено на определени свойства на типа данни. Създадената рамка за имплементация на тестове спомага за лесното разширяване с нова функционалност. 

\end{abstract}

\begin{abstract}

    Random number have widespread usage in a variety of statistical and algorithmic tasks. Through history different ways for generating arbitrary number have been used - roll a dice, draw balls out of a ``well-stirred urn,'' or dealing out cards. The first devices with this goal were created in the middle of the XX century. A number of stochastic tests have been devised in order to try finding an underlying dependency. Randest is a software library of such tests, implemented in C++. Randomness tests can be applied on various types of data, as long as certain operators are defined. The framework allows for easy addition of new tests.

\end{abstract}

\pagebreak

\section{Въведение}

    Числа, които са били „избрани“ случайно, намират широко приложение в разнообразни области. Нуждата от тях може да се наблюдава например при симулация на различни процеси. Така наречените рандомизирани алгоритми често постигат по-добро представяне спрямо детерминистичните си еквиваленти.

    \begin{shadequote}[r]{W. H. Press}
        One of us recalls producing a ``random'' plot with only 11 planes, and being told by his computer center's programming consultant that he had misused the random number generator: ``We guarantee that each number is random individually, but we don't guarantee that more than one of them is random.'' Figure that out.
    \end{shadequote}

    Едно число само по себе си няма как да определим дали е случайно. Нима числото 2 не е вероятен избор? Ами 11111? От друга страна, както става ясно в горния цитат, създаването на \emph{редица} от числа, които да са правилно разпределени в определено разпределение е доста по-трудоемка задача. \cite{Press}

    Възниква следният проблем - компютърът, една напълно детемирнистична машина, трябва да създава призволна, съответно непредвидима, редица от числа. Оставайки настрана този „грях“, описан така от {Нойман}, и за удобство, ще наричаме такива редици псевдо-случайни и ще формулираме свойствата, които те трябва да имат.

    Поради липсата на по-добра дефиниция за редица от псевдо-случайни числа ще използваме следната: \cite{KnuthV2}

    \begin{defn}
        Числата в една редица са произволни, ако никой от тестове, които прилагаме върху нея, не успява да отхвърли това твърдение.
    \end{defn}
    
    Ако някой от прилаганите тестове показва голямо отклонение от теоретичното разпределение, то това означава, че спрямо тази характеристика разглежданата редица не е случайна. Предвид че обикновено има нужда от математически апарат, който да създава редици от привидно произволни числа, за една такава конструкция, ще съдим по това дали успяваме да различим нейния продукт от теоретичното разпределение.

\section{Мотивация}

    Криптографията е област, в която цели системи, широко използвани в съвременните банкови системи, валути и комуникации, включват като градивен елемент възможността за избиране на призволно число. \cite{AppCrypto} От критично значение е този избор да бъде сигурен.

    Пропуск в този градивен елемент може да доведе до пълното разбиване на сигурността на една система, както е показано в \cite{DissingMifare}.

    За изследването на различни конструкции създаващи редица от случайни числа, така наречените Pseudorandom Number Generators (PRNGs), се създават различни софтуерни библиотеки. Началото поставя Кнут през 1969 година. Една от най-новите такива библиотека се нарича TestU01, създадена през 2007. \cite{TestU01}

\section{Принос}

    Статистическите тестове са стандартни, добре описани в множество източници. \cite{KnuthV2} \cite{TestU01} Някои от тях имат имплементации на C.

    Използването на C++11 позволява някои от тестовете да се обобщят, доближавайки се до математическата дефиниция максимално. Така се дава възможност на база дефинирани няколко оператора за тип той да се използва за пресмятанията. Получената имплементация може да бъде преизползвана, в резултат на което лесно се създават нови дефиниции на тестове.

    Пример за преизползване е употребата на теста на Колмогоров-Смирнов. В максималния тест се използва получената генерализирана имплементация, като $F(x)$ се явява параметър. Подробно описание има в §\ref{kstest}.

    При проектирането на библиотеката е постигната абстракция на източникът на данни. Това позволява тестовете да бъдат приложими незавимисимо от това дали данните са записани във файл, генерират се динамично от PRNG или се доставят по друг канал. В допълнение, на базата на тази абстракция, наречена data provider, могат да се имплементират различни модификации на данните, които да запазват старите данни. Подреждането на данните в нарастващ ред подобрява скоростта на пресмятане на някои от статистическите характеристики, както е показано в §\ref{kstest}. Имплементирайки източници на данни, които се явяват модификация на вече съществуващи, спомага за поддържането на добра абстракция между тестове и входа им.

    Стриктното придържане към стандартите на използвания език (препоръчват се опции при компилиране -std=c++11 -pedantic -Werror -Wall) спомага за това библиотеката да остане лесно преносима на разнообразни архитектури. Наличието на някои възможности от стандартната библиотека на C++ е задължително условие.

    Създадените абстракции позволяват лесното добавяне на нови тестове и формирането на множество от тестове.

\section{Статистически характеристики}

    В тази секция ще се опишат тестовете, които са имплементирани към момента в Randest. Колмогоров-Смирнов и $\chi^2$ тестът на Пиърсън са непараметрични статистически тестове, които определят до колко наблюдавано множество се различава от теоретичното разпределение.

    Важно е да се отбележи, че никоя от описаните характеристики и тестове не дават еднозначен отговор дали разглежданата редица от числа е произволна. За потвърждаване или отхвърляне на тази хипотеза трябва да се разгледа статистическата значимост на резултатите от даден тест.
    \subsection{Колмогоров-Смирнов}
    \label{kstest}

        Ако искаме да разгледаме разпределението на случайна стойност $X$, можем да го направим чрез функция на разпределението $F(x)$, така че:
        
        \[
            F(x) = Pr(X \le x) = \text{вероятността $(X \le x)$.}
        \]

        Статистиката на Колмогоров-Смирнов се дефинира по следния начин \cite{kstest}:

        \[
            D_n = \sup_x|F_n(x) - F(x)|
        \]

        $F_n$ емпирична функция на разпределението за $n$ независими и идентично разпределени наблюдения $O_i$ се дефинира като:

        \[
            F_n(x) = \frac{1}{n}\sum_{i=1}^{n}I_{O_i \le x}
        \]
        \[
            I_{O_i \le x} = \begin{cases}
             1, & O_i \le x\\
             0, & O_i > x
            \end{cases}
        \]

        Този тест ще бъде използван с $F(x) = x$, ако не е указано друго, като $x \in [0, 1]$.

    \subsection{$\chi^2$ тест на Пиърсън}

        $\chi^2$ тестът на Пиърсън се използва за разпознаване дали честотното разпределение на множество наблюдения се различава от очакваното теоретично разпределение. В същността си представлява сборът от квадратите на разликата между наблюдаваната честота и очакваната честота за всяко възможно наблюдение. \cite{Pearson1900}
        
        По-нататък в описаните тестове ще се използва очакване за равномерно разпределение на наблюденията. Очакването ще записваме така, като $N$ e броят наблюдения, с които боравим, а $n$ - броят различни възможни наблюдения:

        \[
            E_i = \frac{N}{n}
        \]
        
        С $O_i$ ще означим честотата на срещане на наблюдението $i$ в редицата, която изследваме. Тогава статистиката се дефинира като:

        \[
            \chi^2 = \sum_{i=1}^{n}\frac{(O_i - E_i)^2}{E_i}
        \]

\section{Тестове}

    \subsection{Честотни тестове}

        Имплементирани са два варианта на честотния тест по отношение на цели числа. Първият разглежда дали наблюдаваните числа за равномерно разпределени. Вторият разглежда до колко наблюденията са равномерно разпределени в даден интервал.

        Различаването между двата теста е необходимо. Съществуват генератори на произволни числа, чийто резултат е равномерно разпределен в множеството на възможните изходи, но то не е от последователни цели числа. ването между двата теста е необходимо. Съществуват генератори на произволни числа, чийто резултат е равномерно разпределен в множеството на възможните изходи, но то не е от последователни цели числа. ването между двата теста е необходимо. Съществуват генератори на произволни числа, чийто резултат е равномерно разпределен в множеството на възможните изходи, но то не е от последователни цели числа. ването между двата теста е необходимо. Съществуват генератори на произволни числа, чийто резултат е равномерно разпределен в множеството на възможните изходи, но то не е от последователни цели числа.

        Пример за такъв генератор е Blum-Blum-Shub, който разглежда квадратични остатъци по модул. Свойствата му обуславят успешно приложение в криптографията, но пресмятането му е бавно за симулационни цели (детайли в \cite{BlumBlumShub}).

    \subsection{Максимален тест}

        Максималният тест е описан в добре позната литература и се счита за един от основните, които трябва да бъдат покрити, за по-нататъшното разглеждане на съответния генератор. \cite{KnuthV2} В същността си представлява вземане на максимален елемент от $t$ поредни и разглеждането на статистиката на Колмогоров-Смирнов на получената нова редица.
        
        За $0 \le j < n$, нека

        \[
            V_j = max(U_{tj}, U_{tj + 1}, \dots, U_{tj+t-1})
        \]

        За получената редица $V_j$ се разглежда Колмогоров-Смирнов с $F(x) = x^t$, $0 \le x \le 1$. \cite{KnuthV2}

        За да потвърдим, че $F(x) = x^t$ е правилната функция на разпределението, ще разгледаме вероятността $max(U_1, U_2, \dots, U_t) \le x$. Тя е равна на вероятността $U_1 \le x \text{, } U_2 \le x \text{ и } \dots \text{ и } U_t \le x$, което е произведението на всяка от вероятностите, $x^t$.

    \subsection{Събирач на купони}

        Разглеждаме редицата от неотрицателни числа $X_0, X_1, \dots$ with $0 \le X_i < d$. Наблюдаваме дължините на последователни, нямащи общи членове, подредици, които са с минимална дължина, и съдържат всички неотрицателни числа от $0$ до $d - 1$. Можем да разглеждаме този тест като момче, което събира стикери от кроасани. Съществуват $d$ вида стикери, които са случайно разпределени в опаковките. То трябва да продължава да яде кроасани, докато не събере поне един стикер от всеки вид.
        
        Тестът взима под внимание параметър $t$, който указва максималната дължина, над която се приема, че дължината на тази подредица е $t$. От даден източник на данни тестът работи докато съществуват още данни или докато $n$ пъти бъдат събрани всички купони. За простота се разглеждат единствено завършени колекции. \cite{KnuthV2}

        Прилага се $\chi^2$ тест върху получените бройки за всяка дължина $d, d+1, \dots, t$.

    \subsection{Монотонен тест}

        Една редица редица може да бъде разглеждана спрямо това дали намалява или нараства. Дължината на такива монотонни подредици е характеристиката, която се разглежда в този тест. Стандартна практика е било да се разглеждат едновременно намаляващите и нарастващите подредици, но по-късно е показано, че употребата на $\chi^2$ тест е грешна. \cite{UpsDowns} Това се дължи на факта, че дължината на текущата монотонна редица зависи от дължината на предишната такава.

        В библиотеката е имплементирана вариация на този тест, която Кнут характеризира като „по-проста и практична версия“. След като една монотонна редица бъде прекъсната, следващият елемент се пропуска и се започва разглеждането на нова такава. Резултатните дължини са независими една от друга и върху тях може да бъдет приложен $\chi^2$ тест. \cite{KnuthV2}
        
        Препоръчително е отделното разглеждане на намаляващи подредици и растящи подредици, поради което е имплементирана възможност за използването и на двете.

\section{Бъдещо развитие}
    
    Основен елемент в бъдещето развитие на библиотеката се явява имплементирането на допълнителни тестове. Разширяването на възможностите ще доведе до създаването на библиотека, която да служи за пълноценен емпиричен анализ на различни източници от данни - наблюдения на процеси, генератори на псевдослучайни числа и други.

    Формирането на класове тестове е следващата стъпка, когато бъдат имплементирани голямо множество такива.

    Планирано допълнение към библиотеката е включването на генератори на случайни числа и разширяване на възможните източници на данни. Това ще спомогне за възможността да се сравняват статистическите резултати от различни генератори. 

    Интересна възможност, която заслужава внимание, е идеята да се създаде алгоритъм, който да адаптира параметрите на множество тестове, в зависимост от резултатите им. Предимството на такъв подход е автоматизацията. Към момента, при емпирично изследване, параметрите се изменят от човек, независимо каква библиотека от тестове се използва.

\pagebreak
\bibliography{bib}
\bibliographystyle{plain}

\end{document}
